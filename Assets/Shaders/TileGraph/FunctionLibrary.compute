#pragma kernel IterateLifeCells
#pragma kernel PerlinNoise1D
#pragma kernel PerlinNoise2D
#pragma kernel PerlinNoise3D
#pragma kernel FractalPerlinNoise1D
#pragma kernel FractalPerlinNoise2D
#pragma kernel FractalPerlinNoise3D
#pragma kernel SimplexNoise1D
#pragma kernel SimplexNoise2D
#pragma kernel SimplexNoise3D
#pragma kernel FractalSimplexNoise1D
#pragma kernel FractalSimplexNoise2D
#pragma kernel FractalSimplexNoise3D
#pragma kernel VoronoiNoise2D

// Flattened tilemaps of integers with values 0 and 1 only
RWStructuredBuffer<int>   _TileMapBool0;
RWStructuredBuffer<int>   _TileMapBool1; 
// Flattened tilemaps of floats between 0 and 1 (inclusive)
RWStructuredBuffer<float> _TileMapCont0;
RWStructuredBuffer<float> _TileMapCont1;
// Flattened tilemaps of unsigned integers
RWStructuredBuffer<uint>  _TileMapUint0;
RWStructuredBuffer<uint>  _TileMapUint1;

// Flag used to swap between using _TileMap0 and _TileMap1
// (false = read 0, write 1 | true = read 1, write 0)
bool _BufferFlag = false;

// Bounds of the current tilemap
uint _ScaleX, _ScaleY;

// Seed for random number generation
int _Seed;

// Ruleset for Lifelike Cellular Automata
RWStructuredBuffer<int> _LifeRules;

// Noise scale
float3 _Frequency;

float3 _Offset;

// Fractal Noise parameters
uint _Octaves;
RWStructuredBuffer<float> _Lacunarity, _Persistence;

float _CentroidThreshold;

/**
 * Return the value of the tile at xy in the currently buffered array
 */
int GetBoolTileAt(uint2 xy)
{
    if (xy.x < _ScaleX && xy.y < _ScaleY)
    {
        if (_BufferFlag)
            return _TileMapBool1[xy.x + xy.y * _ScaleX];
        else
            return _TileMapBool0[xy.x + xy.y * _ScaleX];
    }
    else
    {
        return 0;
    }
}
/**
 * Set the value of the tile at xy in the currently buffered array
 */
void SetBoolTileAt(uint2 xy, int value)
{
    if (xy.x < _ScaleX && xy.y < _ScaleY)
    {
        if (_BufferFlag)
            _TileMapBool0[xy.x + xy.y * _ScaleX] = value;
        else
            _TileMapBool1[xy.x + xy.y * _ScaleX] = value;
    }
}

/**
 * Return the value of the tile at xy in the currently buffered array
 */
float GetContTileAt(uint2 xy)
{
    if (xy.x < _ScaleX && xy.y < _ScaleY)
    {
        if (_BufferFlag)
            return _TileMapCont1[xy.x + xy.y * _ScaleX];
        else
            return _TileMapCont0[xy.x + xy.y * _ScaleX];
    }
    else
    {
        return 0.0;
    }
}
/**
 * Set the value of the tile at xy in the currently buffered array
 */
void SetContTileAt(uint2 xy, float value)
{
    if (xy.x < _ScaleX && xy.y < _ScaleY)
    {
        if (_BufferFlag)
            _TileMapCont0[xy.x + xy.y * _ScaleX] = value;
        else
            _TileMapCont1[xy.x + xy.y * _ScaleX] = value;
    }
}


/**
 * Return the value of the tile at xy in the currently buffered array
 */
uint GetUintTileAt(uint2 xy)
{
    if (xy.x < _ScaleX && xy.y < _ScaleY)
    {
        if (_BufferFlag)
            return _TileMapUint1[xy.x + xy.y * _ScaleX];
        else
            return _TileMapUint0[xy.x + xy.y * _ScaleX];
    }
    else
    {
        return 0;
    }
}
/**
 * Set the value of the tile at xy in the currently buffered array
 */
void SetUintTileAt(uint2 xy, uint value)
{
    if (xy.x < _ScaleX && xy.y < _ScaleY)
    {
        if (_BufferFlag)
            _TileMapUint0[xy.x + xy.y * _ScaleX] = value;
        else
            _TileMapUint1[xy.x + xy.y * _ScaleX] = value;
    }
}

uint RandomPCG(uint v)
{
    uint state = v * 74779640u + 2891336453u;
    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
    return (word >> 22u) ^ word;
}
int2 RandomPCG(int2 v)
{
    v = v * 1664525 + 1013904223;
    
    v.x += v.y * 1664525;
    v.y += v.x * 1664525;

    v ^= v >> 16;
    
    v.x += v.y * 1664525;
    v.y += v.x * 1664525;

    v ^= v >> 16;

    return v;
}
uint3 RandomPCG(uint3 v)
{
    v = v * 1664525u + 1013904223u;

    v.x += v.y * v.z;
    v.y += v.z * v.x;
    v.z += v.x * v.y;

    v ^= v >> 16u;

    v.x += v.y * v.z;
    v.y += v.z * v.x;
    v.z += v.x * v.y;

    return v;
}

#include "CellularAutomata.cginc"
#include "Noise.cginc"