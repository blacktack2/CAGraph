#pragma kernel IterateLifeCells
#pragma kernel WhiteNoise1D
#pragma kernel WhiteNoise2D
#pragma kernel WhiteNoise3D
#pragma kernel ValueNoise1D
#pragma kernel ValueNoise2D
#pragma kernel ValueNoise3D
#pragma kernel FractalValueNoise1D
#pragma kernel FractalValueNoise2D
#pragma kernel FractalValueNoise3D
#pragma kernel PerlinNoise1D
#pragma kernel PerlinNoise2D
#pragma kernel PerlinNoise3D
#pragma kernel FractalPerlinNoise1D
#pragma kernel FractalPerlinNoise2D
#pragma kernel FractalPerlinNoise3D
#pragma kernel SimplexNoise1D
#pragma kernel SimplexNoise2D
#pragma kernel SimplexNoise3D
#pragma kernel FractalSimplexNoise1D
#pragma kernel FractalSimplexNoise2D
#pragma kernel FractalSimplexNoise3D
#pragma kernel VoronoiNoise2D
#pragma kernel ThermalErosionPass1
#pragma kernel ThermalErosionPass2
#pragma kernel HydraulicErosionPass1
#pragma kernel HydraulicErosionPass2
#pragma kernel HydraulicErosionPass3
#pragma kernel HydraulicErosionPass4
#pragma kernel HydraulicErosionPass5
#pragma kernel FluvialErosion
#pragma kernel InitErosionTileMap
#pragma kernel UpdateErosionTileMap

static const int MAXINT = 2147483648;

// Flattened tilemaps of integers with values 0 and 1 only
RWStructuredBuffer<int>   _TileMapBool0;
RWStructuredBuffer<int>   _TileMapBool1;
// Flattened tilemaps of floats between 0 and 1 (inclusive)
RWStructuredBuffer<float> _TileMapCont0;
RWStructuredBuffer<float> _TileMapCont1;
// Flattened tilemaps of unsigned integers
RWStructuredBuffer<uint>  _TileMapUint0;
RWStructuredBuffer<uint>  _TileMapUint1;

// Flag used to swap between using _TileMap0 and _TileMap1
// (false = read 0, write 1 | true = read 1, write 0)
bool _BufferFlag = false;

// Bounds of the current tilemap
uint _ScaleX, _ScaleY;

// Seed for random number generation
int _Seed;

// Ruleset for Lifelike Cellular Automata
RWStructuredBuffer<int> _LifeRules;

// Noise scale
float3 _Frequency;

float3 _Offset;
int3 _IntOffset;

// Fractal Noise parameters
uint _Octaves;
RWStructuredBuffer<float> _Lacunarity, _Persistence;

// Theshold value for Voronoi Noise
float _CentroidThreshold;

/**
 * Return the value of the tile at xy in the currently buffered array
 */
int GetBoolTileAt(uint2 xy)
{
    if (xy.x < _ScaleX && xy.y < _ScaleY)
    {
        if (_BufferFlag)
            return _TileMapBool1[xy.x + xy.y * _ScaleX];
        else
            return _TileMapBool0[xy.x + xy.y * _ScaleX];
    }
    else
    {
        return 0;
    }
}
/**
 * Set the value of the tile at xy in the currently buffered array
 */
void SetBoolTileAt(uint2 xy, int value)
{
    if (xy.x < _ScaleX && xy.y < _ScaleY)
    {
        if (_BufferFlag)
            _TileMapBool0[xy.x + xy.y * _ScaleX] = value;
        else
            _TileMapBool1[xy.x + xy.y * _ScaleX] = value;
    }
}

/**
 * Return the value of the tile at xy in the currently buffered array
 */
float GetContTileAt(uint2 xy)
{
    if (xy.x < _ScaleX && xy.y < _ScaleY)
    {
        if (_BufferFlag)
            return _TileMapCont1[xy.x + xy.y * _ScaleX];
        else
            return _TileMapCont0[xy.x + xy.y * _ScaleX];
    }
    else
    {
        return 0.0;
    }
}
/**
 * Set the value of the tile at xy in the currently buffered array
 */
void SetContTileAt(uint2 xy, float value)
{
    if (xy.x < _ScaleX && xy.y < _ScaleY)
    {
        if (_BufferFlag)
            _TileMapCont0[xy.x + xy.y * _ScaleX] = value;
        else
            _TileMapCont1[xy.x + xy.y * _ScaleX] = value;
    }
}


/**
 * Return the value of the tile at xy in the currently buffered array
 */
uint GetUintTileAt(uint2 xy)
{
    if (xy.x < _ScaleX && xy.y < _ScaleY)
    {
        if (_BufferFlag)
            return _TileMapUint1[xy.x + xy.y * _ScaleX];
        else
            return _TileMapUint0[xy.x + xy.y * _ScaleX];
    }
    else
    {
        return 0;
    }
}
/**
 * Set the value of the tile at xy in the currently buffered array
 */
void SetUintTileAt(uint2 xy, uint value)
{
    if (xy.x < _ScaleX && xy.y < _ScaleY)
    {
        if (_BufferFlag)
            _TileMapUint0[xy.x + xy.y * _ScaleX] = value;
        else
            _TileMapUint1[xy.x + xy.y * _ScaleX] = value;
    }
}

uint Random1D(uint seed)
{
    uint state = seed * 74779640 + 2891336453;
    uint word = ((state >> ((state >> 28) + 4)) ^ state) * 277803737;
    return (word >> 22u) ^ word;
}
uint Random1D(uint2 seed)
{
    return Random1D(seed.x ^ Random1D(seed.y));
}
uint Random1D(uint3 seed)
{
    return Random1D(seed.x ^ Random1D(seed.y ^ Random1D(seed.z)));
}
uint2 Random2D(uint seed)
{
    uint x = Random1D(seed);
    uint y = Random1D(x);
    return uint2(x, y);
}
uint2 Random2D(uint2 seed)
{
    uint x = Random1D(seed);
    uint y = Random1D(x);
    return uint2(x, y);
}
uint2 Random2D(uint3 seed)
{
    uint x = Random1D(seed);
    uint y = Random1D(x);
    return uint2(x, y);
}
uint3 Random3D(uint seed)
{
    uint x = Random1D(seed);
    uint y = Random1D(x);
    uint z = Random1D(y);
    return uint3(x, y, z);
}
uint3 Random3D(uint2 seed)
{
    uint x = Random1D(seed);
    uint y = Random1D(x);
    uint z = Random1D(y);
    return uint3(x, y, z);
}
uint3 Random3D(uint3 seed)
{
    uint x = Random1D(seed);
    uint y = Random1D(x);
    uint z = Random1D(y);
    return uint3(x, y, z);
}

#include "CellularAutomata.cginc"
#include "Noise.cginc"
#include "Erosion.cginc"
