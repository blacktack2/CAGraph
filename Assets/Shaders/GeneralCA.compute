#pragma kernel IterateLifeCells

// Flattened matrices of integers
RWStructuredBuffer<int> _Cells0;
RWStructuredBuffer<int> _Cells1;

RWStructuredBuffer<int> _LifeRules;

// Flag used to swap between using _Cells0 and _Cells1
// (false = read 0, write 1 | true = read 1, write 0)
bool _BufferFlag = false;

uint _ScaleX;
uint _ScaleY;

/**
 * Return the state of the cell at xy in the currently buffered array
 */
int GetCellAt(uint2 xy)
{
    if (xy.x < _ScaleX && xy.y < _ScaleY)
    {
        if (_BufferFlag)
            return _Cells1[xy.x + xy.y * _ScaleX];
        else
            return _Cells0[xy.x + xy.y * _ScaleX];
    }
    else
    {
        return false;
    }
}

/**
 * Set the state of the cell at xy in the currently buffered array
 */
void SetCellAt(uint2 xy, int value)
{
    if (xy.x < _ScaleX && xy.y < _ScaleY)
    {
        if (_BufferFlag)
            _Cells0[xy.x + xy.y * _ScaleX] = value;
        else
            _Cells1[xy.x + xy.y * _ScaleX] = value;
    }
}

/**
 * Return the number of neighbours in the Moore neighbourhood of the cell at xy
 */
uint CountNeighboursAt(uint2 xy)
{
    return GetCellAt(xy + int2(-1, -1)) +
           GetCellAt(xy + int2(-1,  0)) +
           GetCellAt(xy + int2(-1,  1)) +
           GetCellAt(xy + int2( 0, -1)) +
           GetCellAt(xy + int2( 0,  1)) +
           GetCellAt(xy + int2( 1, -1)) +
           GetCellAt(xy + int2( 1,  0)) +
           GetCellAt(xy + int2( 1,  1));
}

[numthreads(8, 8, 1)]
void IterateLifeCells(uint3 id: SV_DispatchThreadID)
{
    SetCellAt(id.xy, _LifeRules[GetCellAt(id.xy) * 9 + CountNeighboursAt(id.xy)]);
}
